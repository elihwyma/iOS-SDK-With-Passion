/*
 Image: /System/Library/PrivateFrameworks/CoreSpeech.framework/CoreSpeech
 */

#import <Foundation/NSObject.h>

@class CSAudioCircularBuffer, CSAudioPreprocessor, CSAudioRecordContext, CSAudioRecorder, CSOSTransaction, NSHashTable, NSMutableArray, NSMutableDictionary, NSString, NSUUID;

@protocol CSAudioAlertProvidingDelegate, CSAudioProviderDelegate, CSAudioSessionProvidingDelegate, OS_dispatch_group, OS_dispatch_queue;

@interface CSAudioProvider : NSObject

{
    _Bool _audioSystemRecovering;
    _Bool _waitingForAlertFinish;
    NSString *_UUID;
    NSObject<OS_dispatch_queue> *_recordQueue;
    CSAudioRecorder *_audioRecorder;
    unsigned long long _streamState;
    NSHashTable *_startPendingStreams;
    NSHashTable *_startPendingOnStoppingStreams;
    NSHashTable *_alertPlaybackFinishWaitingStreams;
    NSHashTable *_streams;
    NSHashTable *_stopPendingStreams;
    NSMutableArray *_pendingStartCompletions;
    NSMutableArray *_alertPlaybackFinishWaitingCompletions;
    NSMutableArray *_pendingStopCompletions;
    NSMutableDictionary *_startPendingOnStoppingStreamToCompletionDict;
    id <CSAudioProviderDelegate> _providerDelegate;
    id <CSAudioSessionProvidingDelegate> _sessionDelegate;
    NSMutableArray *_streamHolders;
    NSHashTable *_historicalBufferRequestStreams;
    CSAudioCircularBuffer *_circularBuffer;
    id <CSAudioAlertProvidingDelegate> _alertDelegate;
    CSAudioRecordContext *_lastAudioRecorderContext;
    CSAudioPreprocessor *_audioPreprocessor;
    CSOSTransaction *_recordingTransaction;
    NSObject<OS_dispatch_group> *_recordingWillStartGroup;
    unsigned long long _audioStreamHandleId;
    NSUUID *_alertPlaybackFinishTimeoutToken;
    NSUUID *_startRecordingWatchDogToken;
    NSUUID *_stopRecordingWatchDogToken;
    unsigned long long _circularBufferStartHostTime;
    unsigned long long _circularBufferStartSampleCount;
}

@property (retain, nonatomic) NSObject<OS_dispatch_queue> *recordQueue;
@property (retain, nonatomic) CSAudioRecorder *audioRecorder;
@property (nonatomic) unsigned long long streamState;
@property (retain, nonatomic) NSHashTable *startPendingStreams;
@property (retain, nonatomic) NSHashTable *startPendingOnStoppingStreams;
@property (retain, nonatomic) NSHashTable *alertPlaybackFinishWaitingStreams;
@property (retain, nonatomic) NSHashTable *streams;
@property (retain, nonatomic) NSHashTable *stopPendingStreams;
@property (retain, nonatomic) NSMutableArray *pendingStartCompletions;
@property (retain, nonatomic) NSMutableArray *alertPlaybackFinishWaitingCompletions;
@property (retain, nonatomic) NSMutableArray *pendingStopCompletions;
@property (retain, nonatomic) NSMutableDictionary *startPendingOnStoppingStreamToCompletionDict;
@property (weak, nonatomic) id <CSAudioProviderDelegate> providerDelegate;
@property (weak, nonatomic) id <CSAudioSessionProvidingDelegate> sessionDelegate;
@property (retain, nonatomic) NSMutableArray *streamHolders;
@property (retain, nonatomic) NSHashTable *historicalBufferRequestStreams;
@property (retain, nonatomic) CSAudioCircularBuffer *circularBuffer;
@property (weak, nonatomic) id <CSAudioAlertProvidingDelegate> alertDelegate;
@property (retain, nonatomic) CSAudioRecordContext *lastAudioRecorderContext;
@property (nonatomic) _Bool audioSystemRecovering;
@property (retain, nonatomic) CSAudioPreprocessor *audioPreprocessor;
@property (retain, nonatomic) CSOSTransaction *recordingTransaction;
@property (retain, nonatomic) NSObject<OS_dispatch_group> *recordingWillStartGroup;
@property (nonatomic) _Bool waitingForAlertFinish;
@property (nonatomic) unsigned long long audioStreamHandleId;
@property (retain, nonatomic) NSUUID *alertPlaybackFinishTimeoutToken;
@property (retain, nonatomic) NSUUID *startRecordingWatchDogToken;
@property (retain, nonatomic) NSUUID *stopRecordingWatchDogToken;
@property (nonatomic) unsigned long long circularBufferStartHostTime;
@property (nonatomic) unsigned long long circularBufferStartSampleCount;
@property (nonatomic, readonly) NSString *UUID;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (copy, readonly) NSString *description;
@property (copy, readonly) NSString *debugDescription;

- (void)start;
- (_Bool)isRecording;
- (id)recordRoute;
- (void)enableMiniDucking:(_Bool)arg1;
- (_Bool)setCurrentContext:(id)arg1 error:(id *)arg2;
- (_Bool)setAlertSoundFromURL:(id)arg1 forType:(long long)arg2;
- (_Bool)playAlertSoundForType:(long long)arg1;
- (_Bool)playRecordStartingAlertAndResetEndpointer;
- (void)configureAlertBehavior:(id)arg1;
- (id)recordSettings;
- (void)setMeteringEnabled:(_Bool)arg1;
- (void)updateMeters;
- (float)peakPowerForChannel:(unsigned long long)arg1;
- (float)averagePowerForChannel:(unsigned long long)arg1;
- (unsigned long long)alertStartTime;
- (id)playbackRoute;
- (void)setDuckOthersOption:(_Bool)arg1;
- (_Bool)duckOthersOption;
- (void)saveRecordingBufferFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 toURL:(id)arg3;
- (id)audioStreamWithRequest:(id)arg1 streamName:(id)arg2 error:(id *)arg3;
- (void)CSAudioServerCrashMonitorDidReceiveServerCrash:(id)arg1;
- (void)CSAudioServerCrashMonitorDidReceiveServerRestart:(id)arg1;
- (void)audioPreprocessor:(id)arg1 hasAvailableBuffer:(id)arg2 atTime:(unsigned long long)arg3;
- (id)holdAudioStreamWithDescription:(id)arg1 timeout:(double)arg2;
- (void)cancelAudioStreamHold:(id)arg1;
- (id)initWithAudioStreamHandleId:(unsigned long long)arg1 audioRecorder:(id)arg2;
- (void)setAudioProviderDelegate:(id)arg1;
- (void)audioRecorderBufferAvailable:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 buffer:(id)arg3 remoteVAD:(id)arg4 atTime:(unsigned long long)arg5;
- (void)audioRecorderBufferAvailable:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 buffer:(id)arg3;
- (void)audioRecorderDidStartRecord:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 successfully:(_Bool)arg3 error:(id)arg4;
- (void)audioRecorderDidStopRecord:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 reason:(long long)arg3;
- (void)audioRecorderRecordHardwareConfigurationDidChange:(id)arg1 toConfiguration:(long long)arg2;
- (void)audioRecorderDidFinishAlertPlayback:(id)arg1 ofType:(long long)arg2 error:(id)arg3;
- (void)audioRecorderBeginRecordInterruption:(id)arg1;
- (void)audioRecorderBeginRecordInterruption:(id)arg1 withContext:(id)arg2;
- (void)audioRecorderEndRecordInterruption:(id)arg1;
- (void)audioRecorder:(id)arg1 willSetAudioSessionActive:(_Bool)arg2;
- (void)audioRecorder:(id)arg1 didSetAudioSessionActive:(_Bool)arg2;
- (void)audioRecorderDisconnected:(id)arg1;
- (void)audioRecorderWillBeDestroyed:(id)arg1;
- (void)audioRecorderBuiltInAudioStreamInvalidated:(id)arg1 error:(id)arg2;
- (void)audioRecorderStreamHandleIdInvalidated:(unsigned long long)arg1;
- (_Bool)isNarrowBand;
- (void)triggerInfoForContext:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (_Bool)activateAudioSessionWithReason:(unsigned long long)arg1 error:(id *)arg2;
- (_Bool)prewarmAudioSessionWithError:(id *)arg1;
- (_Bool)deactivateAudioSession:(unsigned long long)arg1 error:(id *)arg2;
- (id)recordDeviceInfo;
- (id)audioMetric;
- (void)setAudioSessionDelegate:(id)arg1;
- (void)setAudioAlertDelegate:(id)arg1;
- (void)audioStreamWithRequest:(id)arg1 streamName:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (_Bool)prepareAudioStreamSync:(id)arg1 request:(id)arg2 error:(id *)arg3;
- (void)prepareAudioStream:(id)arg1 request:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)startAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)stopAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (id)audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2;
- (id)audioChunkToEndFrom:(unsigned long long)arg1;
- (void)saveRecordingBufferToEndFrom:(unsigned long long)arg1 toURL:(id)arg2;
- (void)notifyProviderContextChanged;
- (id)_streamStateName:(unsigned long long)arg1;
- (_Bool)_prepareAudioStreamSync:(id)arg1 request:(id)arg2 error:(id *)arg3;
- (void)_createCircularBufferIfNeeded;
- (id)_audioStreamWithRequest:(id)arg1 streamName:(id)arg2 error:(id *)arg3;
- (void)_handleAudioSystemFailure;
- (void)_startAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)_prepareAudioStream:(id)arg1 request:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (_Bool)_didPlayStartAlertSoundForSiri:(id)arg1 audioStream:(id)arg2;
- (void)_scheduleAlertFinishTimeout:(double)arg1;
- (void)_holdRecordingTransactionIfNeeded;
- (void)_scheduleDidStartRecordingDelegateWatchDog;
- (void)_resetCircularBufferStartTime;
- (void)_clearDidStartRecordingDelegateWatchDog;
- (void)_releaseRecordingTransactionIfNeeded;
- (void)_clearDidStopRecordingDelegateWatchDog;
- (void)_preEpilogueAudioStream;
- (void)_postEpilogueAudioStream;
- (_Bool)_shouldHandleStartPendingOnStopping:(unsigned long long)arg1 withStopReason:(long long)arg2;
- (void)_stopAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (_Bool)_shouldStopRecording;
- (void)_scheduleDidStopRecordingDelegateWatchDog;
- (id)_audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2;
- (void)_saveRecordingBufferFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 toURL:(id)arg3;
- (_Bool)_activateAudioSessionWithReason:(unsigned long long)arg1 error:(id *)arg2;
- (_Bool)_deactivateAudioSession:(unsigned long long)arg1 error:(id *)arg2;
- (_Bool)_isVoiceTriggerInfoAvailableLocally:(id)arg1;
- (void)_processAudioBuffer:(id)arg1 remoteVAD:(id)arg2 atTime:(unsigned long long)arg3;
- (void)_handleDidStartAudioStreamWithResult:(_Bool)arg1 error:(id)arg2;
- (void)_handleDidStopAudioStreamWithReason:(long long)arg1;
- (void)_fetchHistoricalAudioAndForwardToStream:(id)arg1 remoteVAD:(id)arg2;
- (void)_processAudioBufferForWatch:(id)arg1 remoteVAD:(id)arg2 atTime:(unsigned long long)arg3;
- (void)_forwardAudioChunk:(id)arg1 remoteVAD:(id)arg2 atTime:(unsigned long long)arg3 toStream:(id)arg4;
- (void)_didReceiveFinishStartAlertPlaybackAt:(unsigned long long)arg1;
- (void)_schduleDidStartRecordingDelegateWatchDogWithToken:(id)arg1;
- (void)_scheduleDidStopRecordingDelegateWatchDog:(id)arg1;
- (void)_tearDownCircularBufferIfNeeded;

@end
